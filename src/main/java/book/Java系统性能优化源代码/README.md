# java-performance

### 目录

第1章　Java代码优化

1.1　可优化的代码

1.2　性能监控

1.3　JMH

1.3.1　使用JMH

1.3.2　JMH常用设置

1.3.3　注意事项

1.3.4　单元测试

第2章　字符串和数字操作

2.1　构造字符串

2.2　字符串拼接

2.3　字符串格式化

2.4　字符串查找

2.5　替换

2.6　intern方法

2.7　StringUtils类

2.8　前缀树过滤

2.9　数字装箱

2.10　BigDecimal

第3章　并发编程和异步编程

3.1　不安全的代码

3.2　Java并发编程

3.2.1　volatile

3.2.2　synchronized

3.2.3　Lock

3.2.4　Condition

3.2.5　读写锁

3.2.6　Semaphore

3.2.7　栅栏

3.3　Java并发工具

3.3.1　原子变量

3.3.2　Queue

3.3.3　Future

3.3.4　ThreadLocal

3.4　Java线程池

3.5　异步编程

3.5.1　创建异步任务

3.5.2　完成后回调

3.5.3　串行执行

3.5.4　并行执行

3.5.5　接收任务处理结果

第4章　代码性能优化

4.1　int转String

4.2　使用Native方法

4.3　日期格式化

4.4　switch优化

4.5　优先使用局部变量

4.6　预处理

4.7　预分配

4.8　预编译

4.9　预先编码

4.10　谨慎使用Exception

4.11　批处理

4.12　展开循环

4.13　静态方法调用

4.14　高速Map存取

4.15　位运算

4.16　反射

4.17　压缩

4.18　可变数组

4.19　System.nanoTime()

4.20　ThreadLocalRandom

4.21　错误优化策略

4.21.1　final无法帮助内联

4.21.2　subString内存泄漏

4.21.3　循环优化

4.21.4　循环中捕捉异常

第5章　高性能工具

5.1　高速缓存Caffeine

5.1.1　安装Caffeine

5.1.2　Caffeine的基本使用方法

5.1.3　淘汰策略

5.1.4　statistics功能

5.1.5　Caffeine高命中率

5.1.6　卓越的性能

5.2　映射工具Selma

5.3　JSON工具Jackson

5.3.1　Jackson的三种使用方式

5.3.2　Jackson树遍历

5.3.3　对象绑定

5.3.4　流式操作

5.3.5　自定义JsonSerializer

5.3.6　集合的反序列化

5.3.7　性能提升和优化

5.4　HikariCP

5.4.1　安装HikariCP

5.4.2　HikariCP性能测试

5.4.3　性能优化说明

5.5　文本处理工具Beetl

5.5.1　安装和配置

5.5.2　脚本引擎

5.5.3　Beetl的特点

5.5.4　性能优化

5.6　MessagePack

5.7　ReflectASM

第6章　Java注释规范

6.1　Javadoc

6.2　Tag

6.2.1　{@link}

6.2.2　@deprecated

6.2.3　{@literal}

6.2.4　{@code}

6.2.5　{@value}

6.2.6　@author

6.2.7　@param和@return

6.2.8　@throws

6.2.9　@see

6.2.10　自动复制

6.3　Package-Info

6.4　HTML的生成

6.5　Markdown-doclet

第7章　可读性代码

7.1　精简注释

7.2　变量

7.2.1　变量命名

7.2.2　变量的位置

7.2.3　中间变量

7.3　方法

7.3.1　方法签名

7.3.2　短方法

7.3.3　单一职责

7.4　分支

7.4.1　if else

7.4.2　switch case

7.5　发现对象

7.5.1　不要使用String

7.5.2　不要用数组、Map

7.6　checked异常（可控异常）

7.7　其他事项

7.7.1　避免自动格式化

7.7.2　关于Null

第8章　JIT优化

8.1　解释和编译

8.2　C1和C2

8.3　代码缓存

8.4　JITWatch

8.5　内联

8.6　虚方法调用

第9章　代码审查

9.1　ConcurrentHashMap陷阱

9.2　字符串搜索

9.3　I/O输出

9.4　字符串拼接

9.5　方法的入参和出参

9.6　RPC调用定义的返回值

9.7　Integer的使用

9.8　排序

9.9　判断特殊的ID

9.10　优化if结构

9.11　文件复制

9.12　switch优化

9.13　Encoder

9.14　一个JMH例子

9.15　注释

9.16　完善注释

9.17　方法抽取

9.18　遍历Map

9.19　日期格式化

9.20　日志框架设计的问题

9.21　持久化到数据库

9.22　某个RPC框架

9.23　循环调用

9.24　lock的使用

9.25　字符集

9.26　处理枚举值

9.27　任务执行

9.28　开关判断

9.29　JDBC操作

9.30　Controller代码

9.31　停止任务

第10章　ASM运行时增强

10.1　Java字节码

10.1.1　基础知识

10.1.2　.class文件的格式

10.2　Java方法的执行

10.2.1　方法在内存中的表示

10.2.2　方法在.class文件中的表示

10.2.3　指令的分类

10.2.4　操作数栈的变化分析

10.3　Bytecode Outline插件

10.4　ASM入门

10.4.1　生成类名和构造函数

10.4.2　生成main方法

10.4.3　调用生成的代码

10.5　ASM增强代码

10.5.1　使用反射实现

10.5.2　使用ASM生成辅助类

10.5.3　switch语句的分类

10.5.4　获取Bean中的property

10.5.5　switch语句的实现

10.5.6　性能对比

第11章　JSR269编译时增强

11.1　Java编译的过程

11.2　注解处理器入门

11.3　相关概念介绍

11.3.1　AbstractProcessor

11.3.2　Element与TypeMirror

11.4　注解处理器进阶

11.4.1　JsonWriter注解

11.4.2　处理器与生成辅助类

11.4.3　使用生成的Mapper类

11.4.4　注解处理器的使用

11.5　调试注解处理器

11.5.1　在Eclipse中调试注解处理器

11.5.2　在IDEA中调试注解处理

附录A　使用OQL分析虚拟机内存**